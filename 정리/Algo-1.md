# 알고리즘 1

## 2019-07-31

### 기본 설명

* IM:
  * 배열, 리스트
  * `반복문(for,while) 분기문(if-else)`
  * 수식(연산자 + 피연산자)
* AD:
  * 완전 탐색
    * 백트래킹 - BFS, DFS
* 파이썬 장점:
  * 인터프리터 존재 ㅡ> 변수(배열,문자열등)의 크기를 동적으로 할당할 수 있다.
* 일정:
  *  수요일: 실습문제 1개
  *  목요일: 실습문제 5개(4개+1개)
  *  실습한 결과를 Gitlab에 repository 생성해서 올리기(Algorithms)
  *  repository 강사님 초대 <ㅡ jongyun 
  * 소스코드명에 문제번호 포함, 



### 주의할 점

한동안 문제 풀땐 내부함수 쓰지 말기 > 최대한 Python 기본(배열,반복문,수식) 연습하기 위해서

문제 풀 때 Pycharm 쓰기



## APS(Algorithm Problem Solving)

* 기본
  * 배열(LIST)
  * 문자열
  * Stack
  * Queue
  * 연결리스트
  * Tree
* 응용
  * 그래프 (DFS,BFS)
  * 완전탐색
  * 분할정복
  * 백트래킹



### 알고리즘

* 정의: 문제를 해결하기 위한 절차
* 좋은 알고리즘: 얼마나 정확하며 얼마나 효율적인가
  * 정확성(가장 중요!) : 얼마나 정확한가
  * 작업량 : cpu를 얼마나 적게 사용하는가 ㅡ> 실행시간이 얼마나 빠른가
  * 메모리 사용량
  * 단순성
  * 최적성



* 시간 복잡도
  * 실제 걸리는 시간 측정
  * 알고리즘의 효율성을 파악하기위하여 생성
  * n개의 input에 대한 답을 구하기 위해 필요한 시간을 표현
  * 실행되는 연산자의 개수를 계산
  * 표현 종류:
    * o(): 빅오 - 최악의 경우 ex) 순차검색에서 찾고자 하는 값이 없거나 끝에 있을 경우
    * Ω(): 오메가 - 최선의 경우 ex) 순차검색 에서 가장 앞에 값이 있을 경우
    * θ() : 세타 - 최악과 최선이 같은 경우
  * 시간복잡도를 판단해서 11p에 있는 시간복잡도(o(1) ~ o(n!))에 있다면, 그 문제는 쉬운문제라 판단

```python
def fun(n):
    # 명령문 -1번
    for i in range(n):
        # 명령문 - n번
        forj in range(i, n):
            #명령문 - n*(n-1) / 2
            
   #fun(n)이 실행되는 시간은  1 + n + n(n-1)/2
	#BigO(1 + 2 + n(n-1)/2) = n**2(가장 높은 차수)
```

### 배열

* 정의 : 일정한 자료형의 변수들(이건 C, JAVA)을 하나의 이름으로 열거하여 사용하는 자료구조 
* 배열은 기본적으로 반복(for, while, in)과 같이 사용
* C, JAVA ARRAY와 PYTHON LIST 차이점:
  * C, JAVA: INDEX를 통하여 접근
  * PYTHON : POINTER를 통하여 접근
  * 그래서 insert 혹은 del할때 Python 매우 느려진다! >>> Que, Stack 구현이 매우 느려짐
    * 해결 방법: deck? 덱? 뭐냐 이건



## 정렬

* 정의: 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값  혹은 반대로 재배열 하는것

* 종류:

  * 버블 정렬
  * 카운팅 정렬
  * 선택 정렬
  * 퀵 정렬
  * 삽입 정렬
  * 병합 정렬

  

### 버블정렬(Bubble Sort)

* 정의 : 인접한 두 개의 원소를 비교하며 자리 교환



### 카운팅 정렬

* 제한사항:
  * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  * 너무 큰 정수에 대해서는 표현 불가

* 결정 문제

* 최적화 문제

  * 최적해를 구하는 문제

  * 최소 혹은 최대가 되는 경우를 찾는다.

  * `모든 후보해(가능한 경우)를 조사`

  * 순열(n!), 조합, 부분집합(2^n)으로 해결

  * 탐색 기반 - 백트래킹 + (가지치기)

  * 문제간의 관계(재귀적관계) 동적 관계법(메모이

  * 결론: 정답은 완전탐색이다.

    탐욕 기법 사용하기?



### 완전검색

* 문재를 해결할 수 있는 경우의 수를 모두 나열하여 확인하는 기법
* Brute-force 혹은 generate-and-texㅅ라고 부림
* 경우의 수가 적을 때 유용



### 탐욕 알고리즘

* 여러 경우 중 하나를 결정해야 할 때 마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식
* 